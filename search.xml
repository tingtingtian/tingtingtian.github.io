<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>工作简历</title>
    <url>/1994/01/17/introduce/</url>
    <content><![CDATA[<p><img src="/images/woman.jpeg" alt="introduce"></p>
<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><p> Tina ｜ 女 ｜ 汉族 ｜ 未婚 ｜ 1994年1月17日出生 ｜ 山西人 ｜ 本科学历 </p>
<h1 id="教育情况"><a href="#教育情况" class="headerlink" title="教育情况"></a>教育情况</h1><p>2013/09 ~ 2017/07 | 山西农业大学 ｜ 信息与计算科学 ｜ 本科</p>
<h1 id="技能情况"><a href="#技能情况" class="headerlink" title="技能情况"></a>技能情况</h1><ul>
<li>掌握多种开发语言, 熟悉java，golang，了解Solidity ；</li>
<li>熟悉云计算开发流程，熟悉OpenStack及其原理；</li>
<li>掌握区块链以太坊Truffle/Plasma以及Hyperledger 生态 ；</li>
<li>熟悉容器技术docker，及其原理;</li>
<li>熟悉中间件Redis/Kafka/Zookeeper/Etcd/Mysql的使用及其原理；</li>
</ul>
<p>Detail: <a href="https://tingtingtian.github.io" target="_blank" rel="noopener">https://tingtingtian.github.io</a></p>
<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><p>Email: <a href="mailto:2565086122@qq.com" target="_blank" rel="noopener">2565086122@qq.com</a><br>电话:  18404969483</p>
<h1 id="工作项目经历"><a href="#工作项目经历" class="headerlink" title="工作项目经历"></a>工作项目经历</h1><h2 id="2020-12-–-Now"><a href="#2020-12-–-Now" class="headerlink" title="2020/12 – Now"></a>2020/12 – Now</h2><h3 id="建信金科"><a href="#建信金科" class="headerlink" title="建信金科"></a>建信金科</h3><p><strong> 职位 </strong> : 云计算开发工程师<br><strong> 工作描述 </strong></p>
<ul>
<li>负责TCE代码编译及分析；</li>
<li>负责MultiCloud平台相关Provider开发；</li>
<li>负责OpenStack二次开发；</li>
</ul>
<h2 id="2020-06-–-2020-12"><a href="#2020-06-–-2020-12" class="headerlink" title="2020/06 – 2020/12"></a>2020/06 – 2020/12</h2><h3 id="北京网众共创科技有限公司"><a href="#北京网众共创科技有限公司" class="headerlink" title="北京网众共创科技有限公司"></a>北京网众共创科技有限公司</h3><p><strong> 职位 </strong> : 云平台开发工程师<br><strong> 工作描述 </strong></p>
<ul>
<li>负责HCCloud的概要设计、原型设计；</li>
<li>负责HCCloud的前后端研发、测试、上线；</li>
</ul>
<h2 id="2019-07-–-2020-06"><a href="#2019-07-–-2020-06" class="headerlink" title="2019/07 – 2020/06"></a>2019/07 – 2020/06</h2><h3 id="北京航天紫光科技有限公司"><a href="#北京航天紫光科技有限公司" class="headerlink" title="北京航天紫光科技有限公司"></a>北京航天紫光科技有限公司</h3><p><strong> 职位 </strong> : 云平台开发工程师<br><strong> 工作描述 </strong></p>
<ul>
<li>负责OpenStack组件二次开发封装，使其符合私有云的标准；</li>
<li>负责Glance、Flavor组件分页优化以及Glance镜像上传优化；</li>
<li>配合项目经理工作，完成相关概要设计、详细设计；</li>
</ul>
<h2 id="2017-09-–-2019-06"><a href="#2017-09-–-2019-06" class="headerlink" title="2017/09 – 2019/06"></a>2017/09 – 2019/06</h2><h3 id="中电太极集团"><a href="#中电太极集团" class="headerlink" title="中电太极集团"></a>中电太极集团</h3><p><strong> 职位 </strong> : java开发工程师<br><strong> 工作描述 </strong></p>
<ul>
<li>配合项目经理的工作，按照项目计划，按时提交高质量代码，完成开发任务；</li>
<li>参与讨论解决项目中遇到的问题，解决问题；</li>
<li>规范文档的编写、维护，以及其他与项目相关工作。</li>
</ul>
<h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><h2 id="2020-12-–-Now-1"><a href="#2020-12-–-Now-1" class="headerlink" title="2020/12 – Now"></a>2020/12 – Now</h2><h3 id="建信金科-1"><a href="#建信金科-1" class="headerlink" title="建信金科"></a>建信金科</h3><p><strong> 职位 </strong> : 云计算开发工程师</p>
<h4 id="金融云"><a href="#金融云" class="headerlink" title="金融云"></a>金融云</h4><p><strong> 开发环境 </strong> : windows+goland+go15.6<br><strong> 软件架构 </strong> : grpc<br><strong> 项目周期 </strong> : 2020.12～2021.10<br><strong> 项目介绍 </strong> :<br>金融云是基于IaaS层，打造的为银行内部提供一体化云服务，多云产品集成、跨数据中心管理的企业级综合平台，平台应用开源云平台架构，基于KVM\VMWare虚拟化技术，保障了云平台的高可用性。后期加入了对TCE云的支持。云管理平台提供了包括宿主机管理、虚拟机管理、网络管理、存储管理、模版管理、快照管理等资源管理功能。整合多个平台的优质资源，实现多云管理。<br><strong> 责任描述 </strong> :<br>1、主要负责项目中镜像、租户、配额等模块的设计、开发和重构；<br>2、vmware golang sdk 的设计、编写和维护；<br>3、项目中相关模块文档完善。</p>
<h2 id="2019-07-–-2020-06-1"><a href="#2019-07-–-2020-06-1" class="headerlink" title="2019/07 – 2020/06"></a>2019/07 – 2020/06</h2><h3 id="北京航天紫光科技有限公司-1"><a href="#北京航天紫光科技有限公司-1" class="headerlink" title="北京航天紫光科技有限公司"></a>北京航天紫光科技有限公司</h3><p><strong> 职位 </strong> : 云平台开发工程师</p>
<h4 id="CloudOS"><a href="#CloudOS" class="headerlink" title="CloudOS"></a>CloudOS</h4><p><strong> 开发环境 </strong> : windows+idea+jdk1.8<br><strong> 软件架构 </strong> : springBoot+ MyBatis+ MySql+Redis+RabbitMQ+Iview<br><strong> 项目介绍 </strong> ：<br>项目背景：伴随信息化技术的飞跃发展，传统数据中心管理中存在资源瓶颈、信息孤岛、标准不一、系统复杂、服务水平低下等诸多矛盾被愈发激化，IT 的整体管控模式急需向云化模式转型。因此，越来越多的企业和组织正在着力于传统 IT 向云化 IT 转变，并通过云计算技术和服务来实现 IT 的统一运营，提升运营效益。而在业务发展和数字化转型的过程中，越来越多的组织也期望 IT 部门能够敏捷应对持续演变的业务需求，并通过智能应用分析海量的数据，以提高企业的数字化和智能化。<br>项目主要业务：CloudOS云管理系统从业务上来说包括三层业务层、平台层和基础层。业务层主要是由虚拟化平台，云管理平台和运维平台三部分构成；平台层由虚拟化VIM，OpenStack，prometheus三部分构成；基础层由虚拟化VIK,KVM,agent组成的虚拟化与监控和由k8s，centos，docker组成的业务承载支撑。其中业务层的菜单整合，应用整合，权限整合，消息总线等都是由公共服务完成的。工作中所负责的主要是业务层中的云管理平台。云管理平台主要负责对计算，网络，存储等资源进行配置和调度，包括计算，网络，配置三个大模块。计算中包含主机，裸金属，镜像，硬盘，密钥对等功能模块；网络中包含私有网络，虚拟网卡，安全组，路由器等功能模块；配置中包含计算节点，裸金属节点，资源规格，存储类型等功能模块。<br><strong> 责任描述 </strong> :<br>1、主要负责项目中镜像、存储类型、资源规格模块的需求设计，概要设计，详细设计以及代码的开发以及后期BUG的修改；完成资源规格以及存储类型的前端代码，参与镜像前端代码的开发。<br>2、参与项目中重要问题讨论，其中重要的是租户/用户与OpenStack对接解决方案，镜像上传文件速度慢解决方案。</p>
<h2 id="2017-09-–-2019-06-1"><a href="#2017-09-–-2019-06-1" class="headerlink" title="2017/09 – 2019/06"></a>2017/09 – 2019/06</h2><h3 id="中电太极集团-1"><a href="#中电太极集团-1" class="headerlink" title="中电太极集团"></a>中电太极集团</h3><p><strong> 职位 </strong> : java开发工程师</p>
<h4 id="公文传办"><a href="#公文传办" class="headerlink" title="公文传办"></a>公文传办</h4><p><strong> 开发环境 </strong> : windows+eclipse neon+jdk1.8+tomcat7<br><strong> 软件架构 </strong> : Spring + Hibernate + Struts2 +达梦+easyui+poi<br><strong> 开发周期 </strong> : 2018.12~2019.01<br><strong> 项目介绍 </strong> :<br>随着业务的不断发展，客户人员对于文件的处理越来越复杂，错误常常发生，核对量巨大。为了解决这些问题，业务更好更快地发展，我们开发了该系统。该系统主要是对文件进行处理，包括文件登记、文件发送、文件接收、文件传阅、文件回退、文件销毁等等，其间涉及到文件发送的预案设置、文件传阅的传阅机制设置，文件的跨域传递或者域内传递问题；在系统中，同时对各阶段的文件进行统计分析、展示，通过echart中的柱状图，饼状图、折线图等等直观显示了文件的情况，实现了对多阶段文件的综合展示，便于用户对文件大体情况的直观了解。系统上线后，解决了客户的实际问题，促进了公司的发展，得到公司认可和赞誉。<br><strong> 责任描述 </strong> :<br>1、参与项目的讨论；<br>2、按照项目计划，完成任务，提交代码；<br>3、主要负责文件登记、文件发送、预案管理模块儿；<br>4、书写相关项目文档。</p>
<h4 id="数据融合工程"><a href="#数据融合工程" class="headerlink" title="数据融合工程"></a>数据融合工程</h4><p><strong> 开发环境 </strong> : windows+eclipse neon+jdk1.8+tomcat7<br><strong> 软件架构 </strong> : Spring + Mybatis +SpringMvc +DM+Echart+Kafka+Kettle<br><strong> 开发周期 </strong> : 2018.8~2018.10<br><strong> 项目介绍 </strong> :<br>该系统为了实现多数据应用系统数据的融合，得到更有价值的数据，而发起的。该系统分为数据服务层、数据处理层、数据采集层三个主要部分。数据采集层主要利用kettle进行数据抽取，通过数据采集服务器分主题存入主题数据中，并且通过kafka进行主题注册，以topic进行消息管理，发布到某个topic的消息通过策略分布到partition（消息队列），订阅者选择一个topic，会被分配到partition的一个id开始进行消费；数据处理层主要是主题数据建模，建模过程如上所说；数据服务层是一个有SpringMVC+Spring+Mybatis框架实现的数据服务平台，根据需求到Kafka订阅消息，并将获取的消息进行整合处理发送给使用者，并且用echart提供数据可视化展示。<br><strong> 责任描述 </strong> :<br>全程参与项目的设计，开发，测试以及维护，主要负责用ETL工具进行数据采集，并将采集的数据分主题存入主题数据库，负责获取订阅后的信息，并且用echart展示。</p>
<h4 id="标签生成系统"><a href="#标签生成系统" class="headerlink" title="标签生成系统"></a>标签生成系统</h4><p><strong> 开发环境 </strong> : windows+eclipse neon+jdk1.8+tomcat7<br><strong> 软件架构 </strong> : Spring + Mybatis +SpringMvc +MySql<br><strong> 开发周期 </strong> : 2018.6~2018.8<br><strong> 项目介绍 </strong> :<br>该系统为了方便库存装备的盘点、出库、入库，需要对设备标记，实现标签化管理。该系统主要用来制作、修改、查询、标记、重置标签，对多种标签写入的不同数据进行管理，维护。涉及到单个标签，外包装箱标签、包装箱标签等多种不同标签的制作、批量制作、读取、批量读取；在制作完成后涉及到与手持机和应用系统间的数据信息交互。<br><strong> 责任描述 </strong> :<br>全程参与项目的设计，开发，测试以及维护，主要负责单个标签，外包装箱标签、包装箱标签的制作、批量制作、读取、标定以及数据库的远程切换。</p>
]]></content>
  </entry>
  <entry>
    <title>defer执行顺序</title>
    <url>/2021/12/18/defer%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>知识点1：defer的执行顺序</strong></p>
<p>多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。一个函数中，写在前面的defer会比写在后面的defer调用的晚。</p>
<p><strong>知识点2：defer和return的执行顺序</strong></p>
<p>return之后的语句先执行，defer后的语句后执行</p>
<p><strong>知识点3：函数的返回值初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func DeferFunc1(i int) (t int) &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;t = &quot;, t)</span><br><span class="line"></span><br><span class="line">    return 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    DeferFunc11(10)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">t =  0</span><br></pre></td></tr></table></figure>
<p>只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见。</p>
<p><strong>知识点4：有名函数返回值遇见defer情况</strong></p>
<p>先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func returnButDefer() (t int) &#123;  //t初始化0， 并且作用域为该函数全域</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        t = t * 10</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(returnButDefer())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go run test.go</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p><strong>知识点5：defer遇见panic</strong></p>
<p>到panic时，遍历本协程的defer链表，并执行defer。在执行defer过程中:遇到recover则停止panic，返回recover处继续往下执行。如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息。</p>
<p><img src="/images/golang/base/114-defer.jpeg" alt="avatar"></p>
<p><strong>知识点6: defer中包含panic</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">       if err := recover(); err != nil&#123;</span><br><span class="line">           fmt.Println(err)</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           fmt.Println(&quot;fatal&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        panic(&quot;defer panic&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    panic(&quot;panic&quot;)</span><br><span class="line">&#125;</span><br><span class="line">结果</span><br><span class="line"></span><br><span class="line">defer panic</span><br></pre></td></tr></table></figure>
<p><strong>知识点7：defer下的函数参数包含子函数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func function(index int, value int) int &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(index)</span><br><span class="line"></span><br><span class="line">    return index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer function(1, function(3, 0))</span><br><span class="line">    defer function(2, function(4, 0))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里，有4个函数，他们的index序号分别为1，2，3，4。</p>
<p>那么这4个函数的先后执行顺序是什么呢？这里面有两个defer， 所以defer一共会压栈两次，先进栈1，后进栈2。 那么在压栈function1的时候，需要连同函数地址、函数形参一同进栈，那么为了得到function1的第二个参数的结果，所以就需要先执行function3将第二个参数算出，那么function3就被第一个执行。同理压栈function2，就需要执行function4算出function2第二个参数的值。然后函数结束，先出栈fuction2、再出栈function1.</p>
<p> 所以顺序如下：</p>
<p>defer压栈function1，压栈函数地址、形参1、形参2(调用function3) –&gt; 打印3<br>defer压栈function2，压栈函数地址、形参1、形参2(调用function4) –&gt; 打印4<br>defer出栈function2, 调用function2 –&gt; 打印2<br>defer出栈function1, 调用function1–&gt; 打印1<br>3<br>4<br>2<br>1</p>
<p><a href="https://www.topgoer.cn/docs/golangxiuyang/golangxiuyang-1cmee0q64ij5p" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的演进</title>
    <url>/2021/12/20/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E6%BC%94%E8%BF%9B/</url>
    <content><![CDATA[<p>Go语言诞生于2007年，兴起于2015年Go1.5发布之后，16年大热。</p>
<h2 id="1、这是什么原因呢？"><a href="#1、这是什么原因呢？" class="headerlink" title="1、这是什么原因呢？"></a>1、这是什么原因呢？</h2><p>主要是重新设计优化 GC 实现。1.5后也实现了完全使用 Go 语言自身进行编写。</p>
<p>云原生的兴起。Go 语言天生就是为云而生的，在容器中运行时，没有遗留负担。</p>
<p>（Go 语言在 1.3-1.9 的版本更新，都把 GC 放在重要的改进点上。对于 GC 重新优化实现之后，并且迭代了几个版本，在目前来说，对生产环境中大部分使用 JDK7 或者 JDK8 场景下，对比使用 Go 语言的 1.9 版本，还是 Go 语言上的体验会更好一些。）括号里是废话。</p>
<h2 id="2、GC需要做什么呢？"><a href="#2、GC需要做什么呢？" class="headerlink" title="2、GC需要做什么呢？"></a>2、GC需要做什么呢？</h2><p>GC(自动内存管理机制)需要确定<strong>哪些内存需要回收，什么时候回收，怎么回收</strong></p>
<p>在Go中栈上内存仍由编译器负责管理回收，而堆上的内存由编译器和垃圾收集器负责管理回收。</p>
<h3 id="如何确定哪些内存需要回收？"><a href="#如何确定哪些内存需要回收？" class="headerlink" title="如何确定哪些内存需要回收？"></a>如何确定哪些内存需要回收？</h3><p>利用可达性分析的方法来确认哪些内存需要回收</p>
<h3 id="什么时候回收？"><a href="#什么时候回收？" class="headerlink" title="什么时候回收？"></a>什么时候回收？</h3><p>触发GC有俩个条件:</p>
<p>一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发GC。</p>
<p>二是如果一定时间内没有触发，就会触发新的循环，该触发条件由runtime.forcegcperiod变量控制，默认为 2 分钟。</p>
<h3 id="怎么回收"><a href="#怎么回收" class="headerlink" title="怎么回收"></a>怎么回收</h3><p>Go1.3的时候，用的是标记回收算法。Go1.5的时候，用的是三色标记法。Go1.8的时候采用的是三色标记+混合写屏障</p>
<h2 id="3、GC优化的历程"><a href="#3、GC优化的历程" class="headerlink" title="3、GC优化的历程"></a>3、GC优化的历程</h2><h3 id="Go-V1-3-之前，采用标记清除算法。"><a href="#Go-V1-3-之前，采用标记清除算法。" class="headerlink" title="Go V1.3 之前，采用标记清除算法。"></a>Go V1.3 之前，采用标记清除算法。</h3><p>算法步骤如下：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<p>第一步：暂停程序业务逻辑, 找出不可达的对象，然后做上标记。</p>
<p>第二步：开始标记，程序找出它所有可达的对象，并做上标记</p>
<p>第三步：标记完了之后，然后开始清除未标记的对象.</p>
<p>第四步：停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束</p>
<p>缺点是：</p>
<ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<h3 id="Go-V1-5-的三色并发标记法"><a href="#Go-V1-5-的三色并发标记法" class="headerlink" title="Go V1.5 的三色并发标记法"></a>Go V1.5 的三色并发标记法</h3><p>为了解决标记清楚算法引起的整个程序暂停问题，提出三色并发标记法。</p>
<p>第一步：将所有对象标记为白色</p>
<p>第二步：从根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中</p>
<p>第三步：遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色</p>
<p>第四步：循环这个过程</p>
<p>第五步：直到灰色节点集合为空，回收所有的白色节点</p>
<p>缺点：<br>    一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。<br>    BUG：当以下两个条件同时满足时, 就会出现对象丢失现象。</p>
<pre><code>- 条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
- 条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)
</code></pre><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？      </p>
<h3 id="Go-V1-8-的三色标记-混合写屏障-hybrid-write-barrier-机制"><a href="#Go-V1-8-的三色标记-混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="Go V1.8 的三色标记+混合写屏障(hybrid write barrier)机制"></a>Go V1.8 的三色标记+混合写屏障(hybrid write barrier)机制</h3><h4 id="屏障机制："><a href="#屏障机制：" class="headerlink" title="屏障机制："></a>屏障机制：</h4><pre><code>插入屏障机制:在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)  -&gt;强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)
删除屏障机制:被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。-&gt;弱三色不变式. (保护灰色对象到白色对象的路径不会断)
</code></pre><h4 id="短板："><a href="#短板：" class="headerlink" title="短板："></a>短板：</h4><pre><code>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。
</code></pre><p>Go V1.8版本引入了<strong>混合写屏障机制（hybrid write barrier）</strong>，避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<ul>
<li>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</li>
<li>2、GC期间，任何在栈上创建的新对象，均为黑色。</li>
<li>3、被删除的对象标记为灰色。</li>
<li>4、被添加的对象标记为灰色。<br>满足: 变形的弱三色不变式.</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
<p><strong>之后可以拓展到TCmalloc算法（内存管理器）</strong></p>
<h2 id="4、云原生"><a href="#4、云原生" class="headerlink" title="4、云原生"></a>4、云原生</h2><p>云原生的要点可以概括为：DevOps+持续交付+微服务+容器。</p>
<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。<br>云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p>
<p><img src="/images/golang/base/yunyuansheng.jpg" alt="avatar"></p>
<h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps:"></a>DevOps:</h3><ul>
<li>自动化发布管道、CLI工具</li>
<li>快速地部署到生产环境</li>
<li>开发、运维人员协同工作</li>
</ul>
<p>伴随着DevOps出现，那就是CI和CD。CI是Continuous Integration（持续集成），而CD对应多个英文，Continuous Delivery（持续交付）或Continuous Deployment（持续部署）。</p>
<h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付:"></a>持续交付:</h3><ul>
<li>频繁发布、快速交付</li>
<li>快速反馈，降低风险</li>
</ul>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务:"></a>微服务:</h3><ul>
<li>应用间通过标准restful api访问</li>
<li>可以被独立部署、更新、scale和重启</li>
</ul>
<p>不同的工程师可以对各自负责的模块进行处理，例如开发、测试、部署、迭代。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器:"></a>容器:</h3><ul>
<li>微服务的最佳载体</li>
</ul>
<p>不是划分为不同的操作系统，而是在操作系统上划分为不同的“运行环境”（Container），占用资源更少，部署速度更快。</p>
<h2 id="5、Go语言的优略势："><a href="#5、Go语言的优略势：" class="headerlink" title="5、Go语言的优略势："></a>5、Go语言的优略势：</h2><h3 id="Go-语言的核心优势"><a href="#Go-语言的核心优势" class="headerlink" title="Go 语言的核心优势"></a>Go 语言的核心优势</h3><ul>
<li>高速的效率</li>
<li>易学习，成本低</li>
<li>强大的标准库</li>
<li>简单的高并发</li>
<li>部署方便</li>
<li>出身名门、血统纯正</li>
<li>规范性</li>
</ul>
<h3 id="GO语言的缺点"><a href="#GO语言的缺点" class="headerlink" title="GO语言的缺点:"></a>GO语言的缺点:</h3><p>go 2.0 目的是解决目前 go 语言开发者中争议最大的两个问题</p>
<ul>
<li>error 处理</li>
<li>缺乏泛型</li>
</ul>
<p>但是每种编程语言都有它适应的场景，在恰当的场景，使用恰当的语言才能发挥最大的优势。</p>
<h3 id="GO语言的使用项目"><a href="#GO语言的使用项目" class="headerlink" title="GO语言的使用项目"></a>GO语言的使用项目</h3><ul>
<li>docker  Go 语言的重量级选手 Docker 。而 Docker 的生态圈在这几年完全是非一般的发展。</li>
<li>kubernetes（k8s）  Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 Container Pod（容器仓）。</li>
<li>etcd  一款分布式、可靠的 KV 存储系统，可以快速进行云配置。由 CoreOS 开发并维护键值存储系统，它使用 Go 语言编写，并通过 Raft 一致性算法处理日志复制以保证强一致性。</li>
<li><p>beego,codis,devle等等</p>
<p>可以看到，使用 Go 语言的大公司和一些优秀的开源项目都非常之多，并且它就是专门为云上编程的一款语言，而随着基础设施的不断云化，可想而知 Go 语言的未来是不可限量的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>languages</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
</search>
